## CombFoldinator
##
## Snakemake pipeline to fold protein sequences into pdb files
##
import os
import json
import itertools


# What json files are there to process in our pipeline?
INPUTS=[name.replace('.json', '') for name in os.listdir("data/") if name.endswith('json')]

def protein_complex_combinations(json_files):
  """Fetch the query names from the input json
  """
  names = {}
  for json_file in json_files:
    with open(json_file, "r") as f:
      current_json_data = json.load(f)
    filename = os.path.basename(json_file).replace(".json", '')
    current_names = [k for k in current_json_data.keys()]
    names[filename] = current_names
  return names


def determine_pairing_result_files(subunits_dict, ext="pdb"):

  def target_dir(protein_complex, pairing, ext):
    return f"results/data/{protein_complex}/subunits/{ext}/{pairing}.{ext}"
  files = []
  for file in subunits_dict:
    protein_complex = os.path.basename(file)
    subunits = subunits_dict[protein_complex]
    number = ((len(subunits)+1)*len(subunits))//2
    pairings = []
    subunit_a = subunits[0]
    while subunits:
      for subunit in subunits:
        pairing = f"{subunit_a}_{subunit}"
        files.append(target_dir(protein_complex, pairing, ext))
      subunit_a = subunits.pop()
  return files

def determine_pairing_names(subunits_dict):

  files = []
  for file in subunits_dict:
    protein_complex = os.path.basename(file)
    subunits = subunits_dict[protein_complex]
    number = ((len(subunits)+1)*len(subunits))//2
    pairings = []
    subunit_a = subunits[0]
    while subunits:
      for subunit in subunits:
        pairing = f"{subunit_a}_{subunit}"
        pairings.append(target_dir(protein_complex, pairing, ext))
  return pairings 

def fasta_inputs(wildcards):
  complex_combinations = protein_complex_combinations([f"data/{wildcards.protein_complex}.json" for file in INPUTS])
  pairing_targets = determine_pairing(complex_combinations, ext="fasta")
  return pairing_targets

def colabfold_outputs(wildcards):
  complex_combinations = protein_complex_combinations([f"data/{wildcards.protein_complex}.json" for file in INPUTS])
  pairing_targets = determine_pairing(complex_combinations, ext="pdb")
  return pairing_targets

def determine_pairing_names_for_complex(complex_name):
  complex_combinations = protein_complex_combinations([f"data/{complex_name}.json" for file in INPUTS])
  pairing_targets = determine_pairing_names(complex_combinations)
  return pairing_targets

def colabfold_logs(wildcards):
  complex_combinations = protein_complex_combinations([f"data/{wildcards.protein_complex}.json" for file in INPUTS])
  pairing_targets = determine_pairing_names(complex_combinations)
  logs = []
  for pairing_target in pairing_target:
    logs.append(f"logs/colabfold/{wildcards.protein_complex}/pairing_target.log")
  return pairing_targets

COMPLEX_COMBINATIONS = protein_complex_combinations([f"data/{file}.json" for file in INPUTS])



rule all:
  input:
    # The to be processed input files
    expand("results/data/{protein_complex}/subunits/combfold",
        protein_complex=INPUTS)


## Rules
## ------
## preprocess:                Preprocess the input JSON files.
rule preprocess:
  """When the sequences are too long to predict, cut them

  Note not yet implemented yet
  """
  input:
    "data/{protein_complex}.json"
  output:
    "results/data/{protein_complex}/{protein_complex}.json"
  shell:
    """
    cp {input} {output}
    """

rule run_internet_rules:
  """This rule completes all tasks that need internet.
  """
  input:
    "results/checkpoints/setup_cuda"
    "results/checkpoints/setup_combfold"
  output:
    touch("results/setup/ran_internet_dependencies")
      

## setup_combfold:              Compile the COMBFOLD programme. 
rule setup_combfold:
  output:
    touch("results/checkpoints/setup_combfold")
  shell:
    """
    echo "setting up combfold"
    cd workflow/scripts/dependencies/CombFold
    echo "We are in CombFold:"
    ls
    unset PIXI_PROJECT_MANIFEST
    pixi run make
    echo "compilation seems to have been a success!"
    ./CombinatorialAssembler/AF2trans.out --help
    """


## setup_cuda:                Use the cuda hardware for computation.
rule setup_cuda:
  output:
    touch("results/checkpoints/setup_cuda")
  script:
    "scripts/dependencies/setup-cuda.sh"

## produce_fasta:             Convert the json's to fasta inputs.
rule produce_fasta:
  input:
    "results/data/{protein_complex}/{protein_complex}.json"
  output:
    directory("results/data/{protein_complex}/subunits/fasta/")
  shell:
    """
    # files={{output.files}}
    # directory=${{files%/*}}
    cd workflow/scripts/dependencies/CombFold
    unset PIXI_PROJECT_MANIFEST
    pixi run python3 scripts/prepare_fastas.py ../../../../{input} \
      --stage pairs --output-fasta-folder ../../../../{output[0]} \
      --max-af-size 1800
    """

# rule colabfold_msa

rule colabfold_batch:
  input:
    # checkpoint="results/checkpoints/setup_cuda",
    fasta="results/data/{protein_complex}/subunits/fold-msa"
  output:
    directory("results/data/{protein_complex}/subunits/pdb/")
  log:
    "logs/{protein_complex}/colabfold.log"
  shell:
    """
    pixi run colabfold_batch {input.fasta} {output} \
        --num-models 1 > {log} 2>&1
    """

rule colabfold_batch_msa:
  input:
    fasta="results/data/{protein_complex}/subunits/fasta"
  output:
    directory("results/data/{protein_complex}/subunits/fold-msa/")
  log:
    "logs/{protein_complex}/colabfold-msa.log"
  shell:
    """
    pixi run colabfold_batch --msa-only {input.fasta} {output} \
        --num-models 1 > {log} 2>&1
    """
    



## combfold:                  Calculate the complexes from the JSON
##                              file.
rule combfold:
  """Run the combfold programme

  Note --- If a high scoring assembly cannot be found, the programme will
            exit with a nonzero exit code. That is why the usage of 
            `set +e` is needed.
  """
  input:
    "results/checkpoints/setup_combfold",
    json="results/data/{protein_complex}/{protein_complex}.json",
    pdb="results/data/{protein_complex}/subunits/pdb"
  output:
    directory("results/data/{protein_complex}/subunits/combfold")
  shell:
    """
    set +e
    cd workflow/scripts/dependencies/CombFold
    unset PIXI_PROJECT_MANIFEST
    pixi run python3 scripts/run_on_pdbs.py ../../../../{input.json}  \
      ../../../../{input.pdb} output-{wildcards.protein_complex}
    echo "made the following files in output"
    mkdir ../../../../{output} -p
    mv output-{wildcards.protein_complex}/* ../../../../{output}
    """

## help:                      Show the help.
rule help:
  input: "workflow/Snakefile"
  shell:
      "sed -n 's/^##//p' {input}"

## version                    Show the version.
rule version:
  shell:
    """
    git describe --tags --abbrev=0
    """
    

## clean:                     Clean all outputs
rule clean:
    shell:
        "rm -rf results/data*"

## build_overview:            Print the graph.
rule build_overview:
  output:
    "results/method.{fileformat}"
  shell:
    """
    snakemake -c 1 --forceall --dag | dot -T{wildcards.fileformat} > {output}
    """
