## CombFoldinator
##
## Snakemake pipeline to fold protein sequences into pdb files
##
import os
import json
import itertools


# What json files are there to process in our pipeline?
INPUTS=[name.replace('.json', '') for name in os.listdir("data/") if name.endswith('json')]

def protein_complex_combinations(json_files):
  """Fetch the query names from the input json
  """
  names = {}
  for json_file in json_files:
    with open(json_file, "r") as f:
      current_json_data = json.load(f)
    filename = os.path.basename(json_file).replace(".json", '')
    current_names = [k for k in current_json_data.keys()]
    names[filename] = current_names
  return names


def determine_pairing_result_files(subunits_dict, ext="pdb"):

  def target_dir(protein_complex, pairing, ext):
    return f"results/data/{protein_complex}/subunits/{ext}/{pairing}.{ext}"
  files = []
  for file in subunits_dict:
    protein_complex = os.path.basename(file)
    subunits = subunits_dict[protein_complex]
    number = ((len(subunits)+1)*len(subunits))//2
    pairings = []
    subunit_a = subunits[0]
    while subunits:
      for subunit in subunits:
        pairing = f"{subunit_a}_{subunit}"
        files.append(target_dir(protein_complex, pairing, ext))
      subunit_a = subunits.pop()
  return files

def determine_pairing_names(subunits_dict):

  files = []
  for file in subunits_dict:
    protein_complex = os.path.basename(file)
    subunits = subunits_dict[protein_complex]
    number = ((len(subunits)+1)*len(subunits))//2
    pairings = []
    subunit_a = subunits[0]
    while subunits:
      for subunit in subunits:
        pairing = f"{subunit_a}_{subunit}"
        pairings.append(target_dir(protein_complex, pairing, ext))
  return pairings 

def fasta_inputs(wildcards):
  complex_combinations = protein_complex_combinations([f"data/{wildcards.protein_complex}.json" for file in INPUTS])
  pairing_targets = determine_pairing(complex_combinations, ext="fasta")
  return pairing_targets

def colabfold_outputs(wildcards):
  complex_combinations = protein_complex_combinations([f"data/{wildcards.protein_complex}.json" for file in INPUTS])
  pairing_targets = determine_pairing(complex_combinations, ext="pdb")
  return pairing_targets

def determine_pairing_names_for_complex(complex_name):
  complex_combinations = protein_complex_combinations([f"data/{complex_name}.json" for file in INPUTS])
  pairing_targets = determine_pairing_names(complex_combinations)
  return pairing_targets

def colabfold_logs(wildcards):
  complex_combinations = protein_complex_combinations([f"data/{wildcards.protein_complex}.json" for file in INPUTS])
  pairing_targets = determine_pairing_names(complex_combinations)
  logs = []
  for pairing_target in pairing_target:
    logs.append(f"logs/colabfold/{wildcards.protein_complex}/pairing_target.log")
  return pairing_targets

COMPLEX_COMBINATIONS = protein_complex_combinations([f"data/{file}.json" for file in INPUTS])



rule all:
  input:
    # Requirement to install combfold
    "results/checkpoints/setup_combfold",
    # Fasta files for all inputs
    expand("results/data/{complex}/{complex}.json",
        complex=INPUTS),
    # fasta files for each pairing
    expand("results/data/{complex}/subunits/fasta",
        complex=INPUTS),
    # pdb files for each pairing
    expand("results/data/{complex}/subunits/pdb",
        complex=INPUTS),

## Rules:
## preprocess:                Preprocess the input JSON files.
rule preprocess:
  """When the sequences are too long to predict, cut them

  Note not yet implemented yet
  """
  input:
    "data/{protein_complex}.json"
  output:
    "results/data/{protein_complex}/{protein_complex}.json"
  shell:
    """
    cp {input} {output}
    """

rule setup_combfold:
  output:
    touch("results/checkpoints/setup_combfold")
  shell:
    """
    echo "setting up combfold"
    cd workflow/scripts/dependencies/CombFold
    echo "We are in CombFold:"
    ls
    unset PIXI_PROJECT_MANIFEST
    pixi run make
    echo "compilation seems to have been a success!"
    ./CombinatorialAssembler/AF2trans.out --help
    """

## produce_fasta:             Convert the json's to fasta inputs.
rule produce_fasta:
  input:
    "results/data/{protein_complex}/{protein_complex}.json"
  output:
    directory("results/data/{protein_complex}/subunits/fasta/")
  shell:
    """
    # files={{output.files}}
    # directory=${{files%/*}}
    cd workflow/scripts/dependencies/CombFold
    unset PIXI_PROJECT_MANIFEST
    pixi run python3 scripts/prepare_fastas.py ../../../../{input} \
      --stage pairs --output-fasta-folder ../../../../{output[0]} \
      --max-af-size 1800
    """

rule predict_colabfold:
  input:
    "results/data/{protein_complex}/subunits/fasta"
  output:
    directory("results/data/{protein_complex}/subunits/pdb/")
  log:
    "logs/{protein_complex}/colabfold.log"
  shell:
    """
    cd workflow/scripts/dependencies/CombFold
    unset pixi_project_manifest
    pixi run colabfold_batch ../../../../{input} ../../../../{output} \
        --num-models 1 > ../../../../{log} 2>&1
    """


## help:                      Show the help.
rule help:
    input: "workflow/Snakefile"
    shell:
        "sed -n 's/^##//p' {input}"

## clean:                     Clean all outputs
rule clean:
    shell:
        "rm -rf results/data*"

## build_overview:            Print the graph.
rule build_overview:
  output:
    "results/method.{fileformat}"
  shell:
    """
    snakemake -c 1 --forceall --dag | dot -T{wildcards.fileformat} > {output}
    """
